---
layout : layout
title :  Low http response times and normalized backend load using asynchronous request processing
---

#Low http response times and normalized backend load using asynchronous request processing

##Overview

###How does it work (the short version)

When invoking a service-method directly from a http-request-processing thread, it will be occupied until the transaction completes. To avoid this, the request is handed off to a message queue and delivered to a service-activator endpoint. 

if guaranteed delivery is needed, the message queue can be made persistent with a message store. a http ok response is sent only if the message has been added to the queue. 

###Why is it important

Imagine for a second you were summoned as a http-processor-thread in a java webserver serving a http api.

http-threads are a resource you do not want to hog. this is even more important if your application is accessible on the public internet. it is also a good thing to decouple your backend workload from the http-request frequency. updates can be queued while your backend-threads and database eat them up at a steady load.

###When (not) to use this

This pattern is useful if you have to handle a large amount of non trivial create or update requests to your backend in a short amount of time. Consider it especially if you have a public facing api or a spiky usage pattern.   

Its not applicable if the clients requires a response containing processing results. In this case consider to redesign your endpoint api to allow for "fire and forget" style requests: 

Does your client really need to know if the backend transaction completed successfully, or is it enough to acknowledge the delivery? 

Is it possible to pull the backend for results later?     

Obviously, this adds another level of complexity and also some overhead to your application. So only use it, if you need it. Fortunately, if you design your service api with this pattern in mind, its easy to add the implementation later.

##An example





