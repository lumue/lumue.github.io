---
layout : layout
title :  Low http response times and normalized backend load using asynchronous request processing
---

#Low http response times and normalized backend load using asynchronous request processing

##Overview

###Why is it important

Imagine what happens in your application if suddenly a lot of requests start coming in, which demand synchronous transaction execution against a database. The webserver will start to spawn more threads. Each of these threads has to acquire a database connection. This will not only drain your http-threadpool, but also your applications connection pool. after a while, most threads will be waiting for a database connection. which in turn leads to the webserver spawning more and more threads. eventually your application becomes unresponsive. 

So http-threads are a resource you do not want to hog. this is even more important if your application is accessible on the public internet.  

it is also a good thing to decouple your backend workload from the http-request frequency. remember that every thread that executes a transaction against a database likely also occupies a db connection. 


###How does it work (the short version)

When invoking a service-method directly from a http-request-processing thread, it will be occupied until the transaction completes. To avoid this, the request is handed off to a message queue and delivered to a service-activator endpoint. 

this way, updates can be queued while your backend-threads and database eat them up at a steady load.

if guaranteed delivery is needed, the message queue can be made persistent with a message store. a http ok response is sent only if the message has been added to the queue. 



###When (not) to use this

This pattern is useful if you have to handle a large amount of non trivial create or update requests to your backend in a short amount of time. Consider it especially if you have a public facing api or a spiky usage pattern.   

Its not applicable if the clients requires a response containing processing results. In this case consider to redesign your endpoint api to allow for "fire and forget" style requests: 

Does your client really need to know if the backend transaction completed successfully, or is it enough to acknowledge the delivery? 

Is it possible to pull the backend for results later?     

Obviously, this adds another level of complexity and also some overhead to your application. So only use it, if you need it. Fortunately, if you design your service api with this pattern in mind, its easy to add the implementation later.

##An example







